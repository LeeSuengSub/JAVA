# 상속과 다형성

---

## 상속과 다형성(1)

---

### 상속이란?

---

- 클래스를 정의 할때 이미 구현된 클래스를 상속(inheritance)받아서 속성이나 기능이 확장되는 클래스를 구현함

- 상속하는 클래스 : 상위 클래스, parent class, base class, super class
- 상속받는 클래스 : 하위 클래스, child class, derivied class, subclass

- 클래스 상속 문법

```
class B extends A{}
```

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(45).png>)

- 상위 클래스는 하위 클래스보다 일반적인 의미를 가짐
- 하위 클래스는 상위 클래스보다 구체적인 의미를 가짐

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(46).png>)

- extends 뒤에는 단 하나의 class만 사용할 수 있음
- 자바는 single inheritance만을 지원함

- \*\*코드의 재사용의 방법이 상속은 아니다.

#### 상속을 활용한 고객관리 프로그램

---

- 고객의 정보를 활용하여 고객 맞춤 서비스를 구현
- 고객의 등급에 따라 차별화된 할인율과 포인트를 지급
- 등급에 따른 클래스를 따로 구현하는 것이 아닌 일반적인 클래스를 먼저 구현하고 그보다 기능이 많은 클래스는 상속을 활용하여 구현함

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(47).png>)

#### 상속을 활용한 고객관리 프로그램

---

- Customer 클래스 속성

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(48).png>)

- Customer 클래스 메소드

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(49).png>)

#### 새로운 고객 등급이 필요한 경우

---

- 단골고객에 대한 혜택이 필요함
- 우수 고객을 관리하기 위해 다음과 같은 혜택을 줌
  - 고객 등급 : VIP
  - 제품 구매 할인율 : 10%
  - 보너스 포인트 : 5%
  - 담당 전문 상담원 배정

#### VIP 클래스 정의하기

---

- 이미 구현되어 있는 Customer 클래스를 상속받고 Customer 클래스에 구현되지 않은 속성과 메소드를 추가적으로 구현함

## 상속과 다형성(2)

---

### 접근 제한자 가시성

---

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(50).png>)

#### 수정한 Customer 클래스

---

- 따라서 Customer 클래스에 선언된 private 변수를 protected로 선언함

```
    ==> protected int customerID;
    ==> protected String customerName;
	==> protected String customerGrade;
	 int bonusPoint;
	double bonusRatio; // 보너스비율
```

### 상속에서 클래스 생성 과정

---

- 하위 클래스가 생성 될 때 상위 클래스가 먼저 생성됨
- 상위 클래스의 생성자가 호출되고 하위 클래스의 생성자가 호출됨
- 하위 클래스의 생성자에서는 무조건 상위 클래스의 생성자가 호출되어야 함
- 아무것도 없는 경우 컴파일러는 상위 클래스 기본 생성자를 호출하기 위한 super() 를 코드에 넣어줌
- 만약 상위 클래스의 기본생성자가 없는 경우 (매개변수가 있는 생성자만 존재하는 경우) 하위 클래스는 명시적으로 상위 클래스를 호출해야 함

#### 상속에서의 메모리 상태

---

- 상위 클래스의 인스턴스가 먼저 생성이 되고, 하위 클래스의 인스턴스가 생성됨

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(51).png>)

### super 예약어

---

- this가 자기 자신의 인스턴스의 주소를 가지는것처럼 super는 하위 클래스가 상위 클래스에 대한 주소를 가지게 됨
- 하위 클래스가 상위 클래스에 접근 할 때 사용할 수 있음

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(52).png>)

### 상위 클래스로의 묵시적 형 변환(업캐스팅)

---

- 상위 클래스 형으로 변수를 선언하고 하위 클래스 인스턴스를 생성할 수 있음
- 하위 클래스는 상위 클래스의 타입을 내포하고 있음므로 상위 클래스로 묵시적 형변환이 가능함

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(53).png>)

#### 형 변환에서의 메모리

---

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(54).png>)

- VIPCustomer() 생성자의 호출로 인스턴스는 모두 생성 되었지만 타입이 Customer이므로 접근 할수 있는 변수나 메소드는 Customer의 변수와 메소드임

### 메소드 오버라이딩(overriding)

---

- 상위 클래스에 정의 된 메소드 중 하위 클래스와 기능이 맞지 않거나 추가기능이 필요한 경우 같은 이름과 매개변수로 하위 클래스에서 재정의 함

- VIPCustomer 클래스의 calcPrice()메소드 재정의

```
public int calcPrice(int price){
    bonusPoint += price*bonusRatio;
    return price - (int)(price * saleRatio);
}
```

- 보너스 포인트 적립하고 할인률을 적용한 가격을 반환

## 오버라이딩과 다형성(3)

---

### 묵시적 형 변환과 재정의 된 메소드 호출

---

```
Customer vc = new VIPCustomer();
vc.calcPrice(10000);
```

- 위 코드에서 calcPrice()메소드는 어느 메소드가 호출될것인가?

  ![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(55).png>)

### 가상 메소드(virtual method)

---

- 프로그램에서 어떤 객체의 변수나 메소드의 참조는 그 타입에 따라 이루어짐. - 가상 메소드의 경우는 타입과 상관없이 실제 생성된 인스턴스의 메소드가 호출 되는 원리

```
Customer vc = new VIPCustomer();
vc.calcPrice(10000);

vc의 타입은 customer 지만,
실제 생성된 인스턴스인 VIPCustomer 클래스의 calcPrice()메소드가 호출됨
```

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(56).png>)

### 다형성(polymorphism)

---

- 다형성 :
  - 하나의 코드가 여러가지 자료형으로 구현되어 실행되는 것
  - 정보은닉, 상속과 더불어 객체지향 프로그래밍의 가장 큰 특징 중 하나
  - 객체지향 프로그래밍의 유연성, 재활용성, 유지보수성에 기본이 되는 특징임

#### 다형성 구현하기

---

- 하나의 클래스를 상속 받은 여러 클래스가 있는 경우
- 각 클래스마다 같은 이름의 서로 다른 메소드를 재정의 함
- 상위 클래스 타입으로 선언된 하나의 변수가 여러 인스턴스에 대입되어 다양한 구현이 실행될 수 있음

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(57).png>)

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(58).png>)

#### 다형성 활용하기

---

- 일반 고객과 VIP 고객의 중간 등급의 고객을 생성
- 5명의 고객을 ArrayList에 생성하여 저장한 다음
- 각 고객이 물건으 샀을 때의 가격과 보너스 포인트를 계산함

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(59).png>)

### 상속을 언제 사용할까?

---

- 여러 클래스를 생성하지 않고 하나의 클래스에 공통적인 요소를 모으고 나머지 클래스는 이를 상속받은 다음 각각 필요한 특성과 메소드를 구현하는 방법
- 하나의 클래스에 여러 특성을 한꺼번에 구현하는 경우 많은 코드 내에 많은 if문이 생길 수 있음

```
if(customerGrade == "VIP") { //할인해 주고, 적립도 많이 해주고

}else if(customerGrade == "GOLD") { //할인해주고, 적립은 적당히

}else if(customerGrade == "SILVER") { //적립만 해준다.

}
```

- IS-A 관계(is a relationship : inheritance)

  - 일반적인(general) 개념과 구체적인(specific) 개념과의 관계
  - 상위 클래스 : 일반적인 개념 클래스(예: 포유류)
  - 하위 클래스 : 구체적인 개념 클래스(예: 사람, 원숭이, 고래...)
  - 단순히 코드를 재사용하는 목적으로 사용하지 않음

- HAS-A 관계(composition): 한 클래스가 다른 클래스를 소유한 관계

  - 코드 재사용의 한 방법

  ```
  Student 가 Subject를 포함한 관계

  class Student{
    Subject majorSubject;
  }
  ```

## 오버라이딩과 다형성(4)

---

### 다형성 활용하기

---

- 일반 고객과 VIP고개의 중간 등급의 고객을 생성
- 5명의 고객을 ArrayList에 생성하여 저장한 다음 각 고객이 물건으 샀을 때의 가격과 보너스 포인틀르 계산함

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(60).png>)

### 다운 캐스팅 - instanceof

---

- 하위 클래스가 상위 클래스로 형 변환 되는 것은 묵시적으로 이루어짐
- 다시 원래 자료형인 하위 클래스로 형 변환 하려면 명시적으로 다운캐스팅을 해야 함
- 이때 원래 인스턴스의 타입을 체크하는 예약어가 instanceof임

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(61).png>)
