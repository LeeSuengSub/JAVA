# 상속과 다형성

---

## 상속과 다형성(1)

---

### 상속이란?

---

- 클래스를 정의 할때 이미 구현된 클래스를 상속(inheritance)받아서 속성이나 기능이 확장되는 클래스를 구현함

- 상속하는 클래스 : 상위 클래스, parent class, base class, super class
- 상속받는 클래스 : 하위 클래스, child class, derivied class, subclass

- 클래스 상속 문법

```
class B extends A{}
```

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(45).png>)

- 상위 클래스는 하위 클래스보다 일반적인 의미를 가짐
- 하위 클래스는 상위 클래스보다 구체적인 의미를 가짐

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(46).png>)

- extends 뒤에는 단 하나의 class만 사용할 수 있음
- 자바는 single inheritance만을 지원함

- \*\*코드의 재사용의 방법이 상속은 아니다.

#### 상속을 활용한 고객관리 프로그램

---

- 고객의 정보를 활용하여 고객 맞춤 서비스를 구현
- 고객의 등급에 따라 차별화된 할인율과 포인트를 지급
- 등급에 따른 클래스를 따로 구현하는 것이 아닌 일반적인 클래스를 먼저 구현하고 그보다 기능이 많은 클래스는 상속을 활용하여 구현함

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(47).png>)

#### 상속을 활용한 고객관리 프로그램

---

- Customer 클래스 속성

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(48).png>)

- Customer 클래스 메소드

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(49).png>)

#### 새로운 고객 등급이 필요한 경우

---

- 단골고객에 대한 혜택이 필요함
- 우수 고객을 관리하기 위해 다음과 같은 혜택을 줌
  - 고객 등급 : VIP
  - 제품 구매 할인율 : 10%
  - 보너스 포인트 : 5%
  - 담당 전문 상담원 배정

#### VIP 클래스 정의하기

---

- 이미 구현되어 있는 Customer 클래스를 상속받고 Customer 클래스에 구현되지 않은 속성과 메소드를 추가적으로 구현함

## 상속과 다형성(2)

---

### 접근 제한자 가시성

---

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(50).png>)

#### 수정한 Customer 클래스

---

- 따라서 Customer 클래스에 선언된 private 변수를 protected로 선언함

```
    ==> protected int customerID;
    ==> protected String customerName;
	==> protected String customerGrade;
	 int bonusPoint;
	double bonusRatio; // 보너스비율
```

### 상속에서 클래스 생성 과정

---

- 하위 클래스가 생성 될 때 상위 클래스가 먼저 생성됨
- 상위 클래스의 생성자가 호출되고 하위 클래스의 생성자가 호출됨
- 하위 클래스의 생성자에서는 무조건 상위 클래스의 생성자가 호출되어야 함
- 아무것도 없는 경우 컴파일러는 상위 클래스 기본 생성자를 호출하기 위한 super() 를 코드에 넣어줌
- 만약 상위 클래스의 기본생성자가 없는 경우 (매개변수가 있는 생성자만 존재하는 경우) 하위 클래스는 명시적으로 상위 클래스를 호출해야 함

#### 상속에서의 메모리 상태

---

- 상위 클래스의 인스턴스가 먼저 생성이 되고, 하위 클래스의 인스턴스가 생성됨

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(51).png>)

### super 예약어

---

- this가 자기 자신의 인스턴스의 주소를 가지는것처럼 super는 하위 클래스가 상위 클래스에 대한 주소를 가지게 됨
- 하위 클래스가 상위 클래스에 접근 할 때 사용할 수 있음

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(52).png>)

### 상위 클래스로의 묵시적 형 변환(업캐스팅)

---

- 상위 클래스 형으로 변수를 선언하고 하위 클래스 인스턴스를 생성할 수 있음
- 하위 클래스는 상위 클래스의 타입을 내포하고 있음므로 상위 클래스로 묵시적 형변환이 가능함

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(53).png>)

#### 형 변환에서의 메모리

---

![](<./%EC%82%AC%EC%A7%84_%EC%9E%90%EB%A3%8C/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7(54).png>)

- VIPCustomer() 생성자의 호출로 인스턴스는 모두 생성 되었지만 타입이 Customer이므로 접근 할수 있는 변수나 메소드는 Customer의 변수와 메소드임

### 메소드 오버라이딩(overriding)

---

- 상위 클래스에 정의 된 메소드 중 하위 클래스와 기능이 맞지 않거나 추가기능이 필요한 경우 같은 이름과 매개변수로 하위 클래스에서 재정의 함

- VIPCustomer 클래스의 calcPrice()메소드 재정의

```
public int calcPrice(int price){
    bonusPoint += price*bonusRatio;
    return price - (int)(price * saleRatio);
}
```

- 보너스 포인트 적립하고 할인률을 적용한 가격을 반환
